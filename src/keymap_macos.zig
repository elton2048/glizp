const std = @import("std");

pub const KeyError = error{
    UnknownBytes,
};

// Currently using simple key code
// Consider using InputEvent below for a more generic way
pub const KeyCode = enum {
    AltLeft,
    AltRight,
    ArrowDown,
    ArrowLeft,
    ArrowRight,
    ArrowUp,
    BackSlash,
    Backspace,
    BackTick,
    BracketSquareLeft,
    BracketSquareRight,
    CapsLock,
    Comma,
    ControlLeft,
    ControlRight,
    Delete,
    End,
    Enter,
    Escape,
    Equals,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    Fullstop,
    Home,
    Insert,
    Key1,
    Key2,
    Key3,
    Key4,
    Key5,
    Key6,
    Key7,
    Key8,
    Key9,
    Key0,
    Menus,
    Minus,
    Numpad0,
    Numpad1,
    Numpad2,
    Numpad3,
    Numpad4,
    Numpad5,
    Numpad6,
    Numpad7,
    Numpad8,
    Numpad9,
    NumpadEnter,
    NumpadLock,
    NumpadSlash,
    NumpadStar,
    NumpadMinus,
    NumpadPeriod,
    NumpadPlus,
    PageDown,
    PageUp,
    PauseBreak,
    PrintScreen,
    ScrollLock,
    SemiColon,
    ShiftLeft,
    ShiftRight,
    Slash,
    Spacebar,
    Tab,
    Quote,
    WindowsLeft,
    WindowsRight,

    a,
    b,
    c,
    d,
    e,
    f,
    g,
    h,
    i,
    j,
    k,
    l,
    m,
    n,
    o,
    p,
    q,
    r,
    s,
    t,
    u,
    v,
    w,
    x,
    y,
    z,

    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    /// Not on US keyboards
    HashTilde,
    // Scan code set 1 unique codes
    PrevTrack,
    NextTrack,
    Mute,
    Calculator,
    Play,
    Stop,
    VolumeDown,
    VolumeUp,
    WWWHome,
    // Sent when the keyboard boots
    PowerOnTestOk,

    // Control key. Shall be better represented in InputEvent format
    EndOfStream,
};

const InputEvent = struct {
    // Note:
    // 0_0000001
    // Little Endian
    // [6]Ctrl to be 0
    // [5]Shift to be 0
    // ^[ for Alt/Escape key

    ctrl: bool,
    alt: bool,
    shift: bool,
    meta: bool,
    key: KeyCode,
    raw: u8,
};

fn bytesToU32(bytes: []const u8) u32 {
    // Change the byte to u32/u64 for comparsion purpose.
    const btv = std.mem.bytesToValue;
    const byte_u32 = btv(u32, bytes);

    return byte_u32;
}

pub fn mapByteToKeyCode(byte: [4]u8) KeyError!KeyCode {
    const byte_u32 = bytesToU32(&byte);

    return switch (byte_u32) {
        bytesToU32("\x00\xff\xff\xff") => KeyError.UnknownBytes,
        bytesToU32("\x01\xff\xff\xff") => .Escape, // C-a
        bytesToU32("\x02\xff\xff\xff") => .Escape,
        bytesToU32("\x03\xff\xff\xff") => .Escape,
        bytesToU32("\x04\xff\xff\xff") => .EndOfStream,
        bytesToU32("\x05\xff\xff\xff") => .Escape,
        bytesToU32("\x06\xff\xff\xff") => .Escape,
        bytesToU32("\x07\xff\xff\xff") => .Escape,
        bytesToU32("\x08\xff\xff\xff") => .Escape,
        bytesToU32("\x09\xff\xff\xff") => .Tab, // C-i too
        bytesToU32("\x0a\xff\xff\xff") => .Enter, // C-j too
        bytesToU32("\x0b\xff\xff\xff") => .Escape,
        bytesToU32("\x0c\xff\xff\xff") => .Escape,
        bytesToU32("\x0d\xff\xff\xff") => .Escape,
        bytesToU32("\x0e\xff\xff\xff") => .Escape,
        bytesToU32("\x0f\xff\xff\xff") => .Escape,
        bytesToU32("\x10\xff\xff\xff") => .Escape,
        bytesToU32("\x11\xff\xff\xff") => .Escape,
        bytesToU32("\x12\xff\xff\xff") => .Escape,
        bytesToU32("\x13\xff\xff\xff") => .Escape,
        bytesToU32("\x14\xff\xff\xff") => .Escape,
        bytesToU32("\x15\xff\xff\xff") => .Escape,
        bytesToU32("\x16\xff\xff\xff") => .Escape,
        bytesToU32("\x17\xff\xff\xff") => .Escape,
        bytesToU32("\x18\xff\xff\xff") => .Escape,
        bytesToU32("\x19\xff\xff\xff") => .Escape,
        bytesToU32("\x1a\xff\xff\xff") => .Escape,
        bytesToU32("\x1b\xff\xff\xff") => .Escape,
        bytesToU32("\x20\xff\xff\xff") => .Spacebar,
        // TODO: x21 - x2f
        bytesToU32("\x30\xff\xff\xff") => .Key0,
        bytesToU32("\x31\xff\xff\xff") => .Key1,
        bytesToU32("\x32\xff\xff\xff") => .Key2,
        bytesToU32("\x33\xff\xff\xff") => .Key3,
        bytesToU32("\x34\xff\xff\xff") => .Key4,
        bytesToU32("\x35\xff\xff\xff") => .Key5,
        bytesToU32("\x36\xff\xff\xff") => .Key6,
        bytesToU32("\x37\xff\xff\xff") => .Key7,
        bytesToU32("\x38\xff\xff\xff") => .Key8,
        bytesToU32("\x39\xff\xff\xff") => .Key9,
        // TODO: x3a - x3f
        bytesToU32("\x40\xff\xff\xff") => KeyError.UnknownBytes, // Shift - 2(?)
        bytesToU32("\x41\xff\xff\xff") => .A,
        bytesToU32("\x42\xff\xff\xff") => .B,
        bytesToU32("\x43\xff\xff\xff") => .C,
        bytesToU32("\x44\xff\xff\xff") => .D,
        bytesToU32("\x45\xff\xff\xff") => .E,
        bytesToU32("\x46\xff\xff\xff") => .F,
        bytesToU32("\x47\xff\xff\xff") => .G,
        bytesToU32("\x48\xff\xff\xff") => .H,
        bytesToU32("\x49\xff\xff\xff") => .I,
        bytesToU32("\x4a\xff\xff\xff") => .J,
        bytesToU32("\x4b\xff\xff\xff") => .K,
        bytesToU32("\x4c\xff\xff\xff") => .L,
        bytesToU32("\x4d\xff\xff\xff") => .M,
        bytesToU32("\x4e\xff\xff\xff") => .N,
        bytesToU32("\x4f\xff\xff\xff") => .O,
        bytesToU32("\x50\xff\xff\xff") => .P,
        bytesToU32("\x51\xff\xff\xff") => .Q,
        bytesToU32("\x52\xff\xff\xff") => .R,
        bytesToU32("\x53\xff\xff\xff") => .S,
        bytesToU32("\x54\xff\xff\xff") => .T,
        bytesToU32("\x55\xff\xff\xff") => .U,
        bytesToU32("\x56\xff\xff\xff") => .V,
        bytesToU32("\x57\xff\xff\xff") => .W,
        bytesToU32("\x58\xff\xff\xff") => .X,
        bytesToU32("\x59\xff\xff\xff") => .Y,
        bytesToU32("\x5a\xff\xff\xff") => .Z,
        bytesToU32("\x5b\xff\xff\xff") => .BracketSquareLeft,
        bytesToU32("\x5c\xff\xff\xff") => .BackSlash,
        bytesToU32("\x5d\xff\xff\xff") => .BracketSquareRight,
        bytesToU32("\x5e\xff\xff\xff") => KeyError.UnknownBytes, // Shift - 6
        bytesToU32("\x5f\xff\xff\xff") => KeyError.UnknownBytes, // Underscore(Shift - -)
        bytesToU32("\x60\xff\xff\xff") => .BackTick,
        bytesToU32("\x61\xff\xff\xff") => .a,
        bytesToU32("\x62\xff\xff\xff") => .b,
        bytesToU32("\x63\xff\xff\xff") => .c,
        bytesToU32("\x64\xff\xff\xff") => .d,
        bytesToU32("\x65\xff\xff\xff") => .e,
        bytesToU32("\x66\xff\xff\xff") => .f,
        bytesToU32("\x67\xff\xff\xff") => .g,
        bytesToU32("\x68\xff\xff\xff") => .h,
        bytesToU32("\x69\xff\xff\xff") => .i,
        bytesToU32("\x6a\xff\xff\xff") => .j,
        bytesToU32("\x6b\xff\xff\xff") => .k,
        bytesToU32("\x6c\xff\xff\xff") => .l,
        bytesToU32("\x6d\xff\xff\xff") => .m,
        bytesToU32("\x6e\xff\xff\xff") => .n,
        bytesToU32("\x6f\xff\xff\xff") => .o,
        bytesToU32("\x70\xff\xff\xff") => .p,
        bytesToU32("\x71\xff\xff\xff") => .q,
        bytesToU32("\x72\xff\xff\xff") => .r,
        bytesToU32("\x73\xff\xff\xff") => .s,
        bytesToU32("\x74\xff\xff\xff") => .t,
        bytesToU32("\x75\xff\xff\xff") => .u,
        bytesToU32("\x76\xff\xff\xff") => .v,
        bytesToU32("\x77\xff\xff\xff") => .w,
        bytesToU32("\x78\xff\xff\xff") => .x,
        bytesToU32("\x79\xff\xff\xff") => .y,
        bytesToU32("\x7a\xff\xff\xff") => .z,
        bytesToU32("\x7b\xff\xff\xff") => KeyError.UnknownBytes, // Shift - [
        bytesToU32("\x7c\xff\xff\xff") => KeyError.UnknownBytes, // Shift - \
        bytesToU32("\x7d\xff\xff\xff") => KeyError.UnknownBytes, // Shift - ]
        bytesToU32("\x7e\xff\xff\xff") => KeyError.UnknownBytes, // Shift - `
        bytesToU32("\x7f\xff\xff\xff") => .Backspace,
        //
        bytesToU32("\x1b\x5b\x41\xff") => .ArrowUp,
        bytesToU32("\x1b\x5b\x42\xff") => .ArrowDown,
        bytesToU32("\x1b\x5b\x44\xff") => .ArrowLeft,
        bytesToU32("\x1b\x5b\x43\xff") => .ArrowRight,
        else => .A,
    };
}
